open import Data.String hiding (_++_ ; setoid)
open import Data.Nat
open import Function
open import Relation.Unary
open import Relation.Nullary
open import Relation.Nullary.Sum renaming (_‚äé-dec_ to _‚ãÅ-dec_)
open import Relation.Nullary.Product renaming (_√ó-dec_ to _‚ãÄ-dec_)
open import Relation.Nullary.Decidable 
open import Relation.Nullary.Implication
open import Relation.Nullary.Negation
open import Level
open import Data.Product
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Data.Empty
open import Data.List
open import Data.Sum renaming (_‚äé_ to _‚ãÅ_)
open import Data.Fin renaming (_+_ to _fin+_)
open import Data.Integer

module While.Language (n : ‚Ñï) (m : ‚Ñï) where

  module Common where

    infix 71 _mul_ {- todo: correct fixity -}
    infix 71 _min_ {- todo: . -}
    data AExpr {a} (Ident : Set a) : Set a where
      var : Ident ‚Üí AExpr Ident
      lit : ‚Ñ§ ‚Üí AExpr  Ident
      _plus_ : AExpr Ident ‚Üí AExpr Ident ‚Üí AExpr Ident
      _min_ : AExpr Ident ‚Üí AExpr Ident ‚Üí AExpr Ident
      _mul_ : AExpr Ident ‚Üí AExpr Ident ‚Üí AExpr Ident
      
    data BExpr {a} (Ident : Set a) : Set a where
      true : BExpr Ident
      false : BExpr Ident
      not : BExpr Ident ‚Üí BExpr Ident
      _and_ : BExpr Ident ‚Üí BExpr Ident ‚Üí BExpr Ident
      _or_ : BExpr Ident ‚Üí BExpr Ident ‚Üí BExpr Ident
      _gt_ : AExpr Ident ‚Üí AExpr Ident ‚Üí BExpr Ident

    
  module Unlabeled where

    AExpr : Set
    AExpr = Common.AExpr {Level.zero} String
    
    BExpr : Set
    BExpr = Common.BExpr {Level.zero} String
  
    open Common hiding (AExpr ; BExpr)
    
    open import Data.String
    data Stmt : Set where
      _:=_ : (v : String) ‚Üí (e : AExpr) ‚Üí Stmt
      skip :  Stmt
      _seq_ : (s‚ÇÅ : Stmt) ‚Üí (s‚ÇÇ : Stmt) ‚Üí Stmt
      if_then_else_ : (c : BExpr) ‚Üí (t : Stmt) ‚Üí (f : Stmt) ‚Üí Stmt
      while_do_ : (c : BExpr) ‚Üí (b : Stmt) ‚Üí Stmt

    countBlocks : Stmt ‚Üí ‚Ñï
    countBlocks (v := e) = 1
    countBlocks (skip) = 1
    countBlocks (x seq x‚ÇÅ) = countBlocks x Data.Nat.+ countBlocks x‚ÇÅ
    countBlocks (if x then x‚ÇÅ else x‚ÇÇ) = 1 Data.Nat.+ countBlocks x‚ÇÅ Data.Nat.+ countBlocks x‚ÇÇ
    countBlocks (while x do x‚ÇÅ) = 1 Data.Nat.+ countBlocks x‚ÇÅ

--    open import Utilities.ListProperties
    open import Util.List

    countVariables-AExpr : AExpr ‚Üí (xs : List String) ‚Üí NoDupInd xs ‚Üí Œ£[ zs ‚àà List String ] NoDupInd zs
    countVariables-AExpr (var x) xs x‚ÇÅ with x ‚àà?[ Data.String._‚âü_ ] xs
    countVariables-AExpr (var x) xs x‚ÇÅ | yes p = xs , x‚ÇÅ
    countVariables-AExpr (var x) xs x‚ÇÅ | no ¬¨p = (x ‚à∑ xs) , (¬¨p ::: x‚ÇÅ)
    countVariables-AExpr (lit x) xs x‚ÇÅ = xs , x‚ÇÅ
    countVariables-AExpr (x plus x‚ÇÅ) xs x‚ÇÇ = let (ys , p) = countVariables-AExpr x xs x‚ÇÇ
                                             in countVariables-AExpr x‚ÇÅ ys p
    countVariables-AExpr (x min x‚ÇÅ) xs x‚ÇÇ = let (ys , p) = countVariables-AExpr x xs x‚ÇÇ
                                            in countVariables-AExpr x‚ÇÅ ys p
    countVariables-AExpr (x mul x‚ÇÅ) xs x‚ÇÇ = let (ys , p) = countVariables-AExpr x xs x‚ÇÇ
                                            in countVariables-AExpr x‚ÇÅ ys p

    countVariables-BExpr : BExpr ‚Üí (xs : List String) ‚Üí NoDupInd xs ‚Üí Œ£[ zs ‚àà List String ] NoDupInd zs
    countVariables-BExpr true xs x‚ÇÅ = xs , x‚ÇÅ
    countVariables-BExpr false xs x‚ÇÅ = xs , x‚ÇÅ
    countVariables-BExpr (not x) xs x‚ÇÅ = xs , x‚ÇÅ
    countVariables-BExpr (x and x‚ÇÅ) xs x‚ÇÇ = let (ys , p) = countVariables-BExpr x xs x‚ÇÇ
                                            in countVariables-BExpr x‚ÇÅ ys p
    countVariables-BExpr (x or x‚ÇÅ) xs x‚ÇÇ = let (ys , p) = countVariables-BExpr x xs x‚ÇÇ
                                           in countVariables-BExpr x‚ÇÅ ys p
    countVariables-BExpr (x gt x‚ÇÅ) xs x‚ÇÇ = let (ys , p) = countVariables-AExpr x xs x‚ÇÇ
                                           in countVariables-AExpr x‚ÇÅ ys p

    countVariables-Stmt : Stmt ‚Üí (xs : List String) ‚Üí NoDupInd xs ‚Üí Œ£[ zs ‚àà List String ] NoDupInd zs
    countVariables-Stmt (v := e) xs q with v ‚àà?[ Data.String._‚âü_ ] xs
    countVariables-Stmt (v := e) xs q | yes p = xs , q
    countVariables-Stmt (v := e) xs q | no ¬¨p = (v ‚à∑ xs) , ¬¨p ::: q
    countVariables-Stmt skip xs q = xs , q
    countVariables-Stmt (x seq x‚ÇÅ) xs q = let (ys , p) = countVariables-Stmt x xs q
                                          in countVariables-Stmt x‚ÇÅ ys p 
    countVariables-Stmt (if c then x else x‚ÇÅ) xs q = let (ys , p) = countVariables-BExpr c xs q
                                                         (zs , r) = countVariables-Stmt x ys p
                                                     in countVariables-Stmt x‚ÇÅ zs r
    countVariables-Stmt (while c do x) xs q = let (zs , p) = countVariables-BExpr c xs q
                                              in countVariables-Stmt x zs p

    allVariables : Stmt ‚Üí Œ£[ zs ‚àà List String ] NoDupInd zs
    allVariables s = countVariables-Stmt s [] end

    numVariables : Stmt ‚Üí ‚Ñï
    numVariables s = length (proj‚ÇÅ (allVariables s))

  

  module Labeled (program : Unlabeled.Stmt)  where
    Var : Set
    Var = Fin (Unlabeled.numVariables program)
      
    Lab : Set
    Lab = Fin (Unlabeled.countBlocks program)

    AExpr : Set
    AExpr = Common.AExpr {Level.zero} Var
    
    BExpr : Set
    BExpr = Common.BExpr {Level.zero} Var
    
    open Common hiding (AExpr ; BExpr) public
    
    infixr 50 _seq_
    infixr 60 while_do_
    infix 70 _:=_
    data Stmt : Set where
      _:=_ : (v : Var) ‚Üí (e : AExpr) ‚Üí (l : Lab) ‚Üí Stmt
      skip : (l : Lab) ‚Üí Stmt
      _seq_ : (s‚ÇÅ : Stmt) ‚Üí (s‚ÇÇ : Stmt) ‚Üí Stmt
      if_then_else_ : (BExpr √ó Lab) ‚Üí (t : Stmt) ‚Üí (f : Stmt) ‚Üí Stmt
      while_do_ : (BExpr √ó Lab) ‚Üí (b : Stmt) ‚Üí Stmt

--    open import Utilities.ListProperties


    data Block : Set where
      skip : (l : Lab) ‚Üí Block
      _:=_ : (x : Var) ‚Üí (a : AExpr) ‚Üí (l : Lab) ‚Üí Block
      bExpr : (c : BExpr) ‚Üí (l : Lab) ‚Üí Block
 
    module ùïç where
      open import Data.Vec public
    open import Data.Vec using (_‚à∑_ ; Vec)

    {-
    blocks' : (p : Unlabeled.Stmt) ‚Üí Vec Block (Unlabeled.countBlocks p)
    blocks' (v Unlabeled.:= e) = (({!!} := e) {!!}) ‚à∑ ùïç.[]
    blocks' (Unlabeled.skip) = (skip {!!}) ‚à∑ ùïç.[] 
    blocks' (p Unlabeled.seq p‚ÇÅ) = blocks' p Data.Vec.++ blocks' p‚ÇÅ
    blocks' (Unlabeled.if b then p else p‚ÇÅ) = (bExpr b {!!}) ‚à∑ (blocks' p Data.Vec.++ blocks' p‚ÇÅ)
    blocks' (Unlabeled.while b do p) = (bExpr b {!!}) ‚à∑ (blocks' p)
                                                       
    blocks : Vec Block (Unlabeled.countBlocks program)
    blocks = blocks' program
    -}
    open import Relation.Binary
    open import Data.Product
    open import Relation.Nullary.Product
    open import Data.Fin.Properties
  
    _‚âüA_ : Relation.Binary.Decidable {A = AExpr} _‚â°_
    var x ‚âüA var x‚ÇÅ with x Data.Fin.Properties.‚âü x‚ÇÅ
    var x ‚âüA var x‚ÇÅ | yes p = yes (cong var p)
    var x ‚âüA var x‚ÇÅ | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p refl})
    var x ‚âüA lit x‚ÇÅ = no (Œª{ ()})
    var x ‚âüA (y plus y‚ÇÅ) = no (Œª{ ()})
    var x ‚âüA (y min y‚ÇÅ) = no (Œª{ ()})
    var x ‚âüA (y mul y‚ÇÅ) = no (Œª{ ()})
    lit x ‚âüA var x‚ÇÅ = no (Œª{ ()})
    lit x ‚âüA lit x‚ÇÅ with x Data.Integer.‚âü x‚ÇÅ
    lit x ‚âüA lit x‚ÇÅ | yes p = yes (cong lit p)
    lit x ‚âüA lit x‚ÇÅ | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p refl})
    lit x ‚âüA (y plus y‚ÇÅ) = no (Œª{ ()})
    lit x ‚âüA (y min y‚ÇÅ) = no (Œª{ ()})
    lit x ‚âüA (y mul y‚ÇÅ) = no (Œª{ ()})
    (x plus x‚ÇÅ) ‚âüA var x‚ÇÇ = no (Œª{ ()})
    (x plus x‚ÇÅ) ‚âüA lit x‚ÇÇ = no (Œª{ ()})
    (x plus x‚ÇÅ) ‚âüA (y plus y‚ÇÅ) with x ‚âüA y √ó-dec x‚ÇÅ ‚âüA y‚ÇÅ
    (x plus x‚ÇÅ) ‚âüA (y plus y‚ÇÅ) | yes (proj‚ÇÅ , proj‚ÇÇ) = yes (cong‚ÇÇ _plus_ proj‚ÇÅ proj‚ÇÇ)
    (x plus x‚ÇÅ) ‚âüA (y plus y‚ÇÅ) | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p (refl , refl)})
    (x plus x‚ÇÅ) ‚âüA (y min y‚ÇÅ) = no (Œª{ ()})
    (x plus x‚ÇÅ) ‚âüA (y mul y‚ÇÅ) = no (Œª{ ()})
    (x min x‚ÇÅ) ‚âüA var x‚ÇÇ = no (Œª{ ()})
    (x min x‚ÇÅ) ‚âüA lit x‚ÇÇ = no (Œª{ ()})
    (x min x‚ÇÅ) ‚âüA (y plus y‚ÇÅ) = no (Œª{ ()})
    (x min x‚ÇÅ) ‚âüA (y min y‚ÇÅ) with x ‚âüA y √ó-dec x‚ÇÅ ‚âüA y‚ÇÅ
    (x min x‚ÇÅ) ‚âüA (y min y‚ÇÅ) | yes (proj‚ÇÅ , proj‚ÇÇ) = yes (cong‚ÇÇ _min_ proj‚ÇÅ proj‚ÇÇ)
    (x min x‚ÇÅ) ‚âüA (y min y‚ÇÅ) | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p (refl , refl)})
    (x min x‚ÇÅ) ‚âüA (y mul y‚ÇÅ) = no (Œª{ ()})
    (x mul x‚ÇÅ) ‚âüA var x‚ÇÇ = no (Œª{ ()})
    (x mul x‚ÇÅ) ‚âüA lit x‚ÇÇ = no (Œª{ ()})
    (x mul x‚ÇÅ) ‚âüA (y plus y‚ÇÅ) = no (Œª{ ()})
    (x mul x‚ÇÅ) ‚âüA (y min y‚ÇÅ) = no (Œª{ ()})
    (x mul x‚ÇÅ) ‚âüA (y mul y‚ÇÅ) with x ‚âüA y √ó-dec x‚ÇÅ ‚âüA y‚ÇÅ
    (x mul x‚ÇÅ) ‚âüA (y mul y‚ÇÅ) | yes (proj‚ÇÅ , proj‚ÇÇ) = yes (cong‚ÇÇ _mul_ proj‚ÇÅ proj‚ÇÇ)
    (x mul x‚ÇÅ) ‚âüA (y mul y‚ÇÅ) | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p (refl , refl)})
  
  
    _‚âüB_ : Relation.Binary.Decidable {A = BExpr} _‚â°_
    true ‚âüB true = yes refl
    true ‚âüB false = no (Œª{ ()})
    true ‚âüB not y = no (Œª{ ()})
    true ‚âüB (y and y‚ÇÅ) = no (Œª{ ()})
    true ‚âüB (y or y‚ÇÅ) = no (Œª{ ()})
    true ‚âüB (x gt x‚ÇÅ) = no (Œª{ ()})
    false ‚âüB true = no (Œª{ ()})
    false ‚âüB false = yes refl
    false ‚âüB not y = no (Œª{ ()})
    false ‚âüB (y and y‚ÇÅ) = no (Œª{ ()})
    false ‚âüB (y or y‚ÇÅ) = no (Œª{ ()})
    false ‚âüB (x gt x‚ÇÅ) =  no (Œª{ ()})
    not x ‚âüB true =  no (Œª{ ()})
    not x ‚âüB false =  no (Œª{ ()})
    not x ‚âüB not y with x ‚âüB y
    not x ‚âüB not y | yes p = yes (cong not p)
    not x ‚âüB not y | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p refl})
    not x ‚âüB (y and y‚ÇÅ) =  no (Œª{ ()})
    not x ‚âüB (y or y‚ÇÅ) =  no (Œª{ ()})
    not x ‚âüB (x‚ÇÅ gt x‚ÇÇ) =  no (Œª{ ()})
    (x and x‚ÇÅ) ‚âüB true = no (Œª{ ()})
    (x and x‚ÇÅ) ‚âüB false = no (Œª{ ()})
    (x and x‚ÇÅ) ‚âüB not y = no (Œª{ ()})
    (x and x‚ÇÅ) ‚âüB (y and y‚ÇÅ) with x ‚âüB y | x‚ÇÅ ‚âüB y‚ÇÅ
    (x and x‚ÇÅ) ‚âüB (y and y‚ÇÅ) | yes p | yes p‚ÇÅ = yes (cong‚ÇÇ _and_ p p‚ÇÅ)
    (x and x‚ÇÅ) ‚âüB (y and y‚ÇÅ) | no ¬¨p | yes p =  no (Œª{ refl ‚Üí ¬¨p refl})
    (x and x‚ÇÅ) ‚âüB (y and y‚ÇÅ) | yes p | no ¬¨p =  no (Œª{ refl ‚Üí ¬¨p refl})
    (x and x‚ÇÅ) ‚âüB (y and y‚ÇÅ) | no ¬¨p | no ¬¨p‚ÇÅ = no (Œª{ refl ‚Üí ¬¨p refl})
    (x and x‚ÇÅ) ‚âüB (y or y‚ÇÅ) = no (Œª{ ()})
    (x and x‚ÇÅ) ‚âüB (x‚ÇÇ gt x‚ÇÉ) = no (Œª{ ()})
    (x or x‚ÇÅ) ‚âüB true =  no (Œª{ ()})
    (x or x‚ÇÅ) ‚âüB false =  no (Œª{ ()})
    (x or x‚ÇÅ) ‚âüB not y =  no (Œª{ ()})
    (x or x‚ÇÅ) ‚âüB (y and y‚ÇÅ) =  no (Œª{ ()})
    (x or x‚ÇÅ) ‚âüB (y or y‚ÇÅ) with x ‚âüB y √ó-dec x‚ÇÅ ‚âüB y‚ÇÅ
    (x or x‚ÇÅ) ‚âüB (y or y‚ÇÅ) | yes (proj‚ÇÅ , proj‚ÇÇ) = yes (cong‚ÇÇ _or_ proj‚ÇÅ proj‚ÇÇ)
    (x or x‚ÇÅ) ‚âüB (y or y‚ÇÅ) | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p (refl , refl)})
    (x or x‚ÇÅ) ‚âüB (x‚ÇÇ gt x‚ÇÉ) =  no (Œª{ ()})
    (x gt x‚ÇÅ) ‚âüB true =  no (Œª{ ()})
    (x gt x‚ÇÅ) ‚âüB false =  no (Œª{ ()})
    (x gt x‚ÇÅ) ‚âüB not y =  no (Œª{ ()})
    (x gt x‚ÇÅ) ‚âüB (y and y‚ÇÅ) =  no (Œª{ ()})
    (x gt x‚ÇÅ) ‚âüB (y or y‚ÇÅ) =  no (Œª{ ()})
    (x gt x‚ÇÅ) ‚âüB (x‚ÇÇ gt x‚ÇÉ) with x ‚âüA x‚ÇÇ √ó-dec x‚ÇÅ ‚âüA x‚ÇÉ
    (x gt x‚ÇÅ) ‚âüB (x‚ÇÇ gt x‚ÇÉ) | yes (proj‚ÇÅ , proj‚ÇÇ) = yes (cong‚ÇÇ _gt_ proj‚ÇÅ proj‚ÇÇ)
    (x gt x‚ÇÅ) ‚âüB (x‚ÇÇ gt x‚ÇÉ) | no ¬¨p = no (Œª{ refl ‚Üí ¬¨p ((refl , refl))})
  
    init : Stmt ‚Üí Lab
    init ((v := e) l) = l
    init (skip x) = x
    init (s seq s‚ÇÅ) = init s
    init (if proj‚ÇÅ , proj‚ÇÇ then s else s‚ÇÅ) = proj‚ÇÇ
    init (while proj‚ÇÅ , proj‚ÇÇ do s) = proj‚ÇÇ

    import Data.List.NonEmpty as L‚Å∫
    final : Stmt ‚Üí L‚Å∫.List‚Å∫ Lab
    final ((v := e) l) = L‚Å∫.[ l ]
    final (skip l) = L‚Å∫.[ l ]
    final (s seq s‚ÇÅ) = final s‚ÇÅ
    final (if proj‚ÇÅ , proj‚ÇÇ then s else s‚ÇÅ) = final s L‚Å∫.‚Å∫++‚Å∫ final s‚ÇÅ
    final (while proj‚ÇÅ , proj‚ÇÇ do s) = L‚Å∫.[ proj‚ÇÇ ]

    getLab : Block ‚Üí Lab
    getLab (skip l) = l
    getLab ((x := a) l) = l
    getLab (bExpr c l) = l
  
  
    labels : Stmt ‚Üí List Lab
    labels ((v := e) l) = Data.List.[ l ]
    labels (skip l) = Data.List.[ l ]
    labels (s seq s‚ÇÅ) = labels s Data.List.++ labels s‚ÇÅ
    labels (if x then s else s‚ÇÅ) = proj‚ÇÇ x ‚à∑ labels s Data.List.++ labels s‚ÇÅ
    labels (while x do s) = proj‚ÇÇ x ‚à∑ labels s
  
    flow : Stmt ‚Üí List (Lab √ó Lab)
    flow ((v := e) l) = []
    flow (skip l) = []
    flow (s seq s‚ÇÅ) = flow s ++ flow s‚ÇÅ ++ L‚Å∫.toList (L‚Å∫.map (Œª x ‚Üí x , init s‚ÇÅ) (final s)) 
    flow (if x then s else s‚ÇÅ) = ((proj‚ÇÇ x) , (init s)) ‚à∑ ((proj‚ÇÇ x) , (init s‚ÇÅ)) ‚à∑ flow s ++ flow s‚ÇÅ
    flow (while x do s) = ((proj‚ÇÇ x) , (init s)) ‚à∑ flow s ++ L‚Å∫.toList (L‚Å∫.map (Œª l' ‚Üí l' , proj‚ÇÇ x) (final s))
  
    open import Data.Graph {!!}

    flow·¥ø : Stmt ‚Üí List (Lab √ó Lab)
    flow·¥ø s = flow s ·¥ø
    
    Var*-AExpr : AExpr ‚Üí List Var
    Var*-AExpr (var x) = [ x ]
    Var*-AExpr (lit x) = []
    Var*-AExpr (a plus a‚ÇÅ) = Var*-AExpr a ++ Var*-AExpr a‚ÇÅ
    Var*-AExpr (a min a‚ÇÅ) = Var*-AExpr a ++ Var*-AExpr a‚ÇÅ
    Var*-AExpr (a mul a‚ÇÅ) = Var*-AExpr a ++ Var*-AExpr a‚ÇÅ
  
    Var*-BExpr : BExpr ‚Üí List Var
    Var*-BExpr true = []
    Var*-BExpr false = []
    Var*-BExpr (not b) = []
    Var*-BExpr (b and b‚ÇÅ) = []
    Var*-BExpr (b or b‚ÇÅ) = []
    Var*-BExpr (x gt x‚ÇÅ) = Var*-AExpr x ++ Var*-AExpr x‚ÇÅ

    Var* : Stmt ‚Üí List Var
    Var* ((v := e) l) = v ‚à∑ Var*-AExpr e
    Var* (skip l) = []
    Var* (s seq s‚ÇÅ) = Var* s ++ Var* s‚ÇÅ
    Var* (if proj‚ÇÅ , proj‚ÇÇ then s else s‚ÇÅ) = Var*-BExpr proj‚ÇÅ ++ Var* s ++ Var* s‚ÇÅ
    Var* (while proj‚ÇÅ , proj‚ÇÇ do s) = Var*-BExpr proj‚ÇÅ ++ Var* s
  
  open import Util.List
  open import Data.List.Any
  toLabeled : (us : Unlabeled.Stmt) ‚Üí (open Labeled us) ‚Üí (xs : List String) ‚Üí NoDupInd xs ‚Üí Œ£[ zs ‚àà List String ]
                                                                                             Œ£[ s ‚àà Stmt ] NoDupInd zs
  toLabeled (v Unlabeled.:= e) xs p with v ‚àà?[ Data.String._‚âü_ ] xs
  toLabeled (v Unlabeled.:= e) xs p | yes q = xs , (({!index q!} Labeled.:= {!!}) {!!} , p)
  toLabeled (v Unlabeled.:= e) xs p | no ¬¨q = {!!}
  toLabeled Unlabeled.skip = {!!}
  toLabeled (x Unlabeled.seq x‚ÇÅ) = {!!}
  toLabeled (Unlabeled.if c then x else x‚ÇÅ) = {!!}
  toLabeled (Unlabeled.while c do x) = {!!}

--  open Common public
--  open Common.AExpr public
  
  --open Common.AExpr {Level.zero} Var
  --open Common.BExpr {Level.zero} Var


  {-
  data Stmt : Set where
    _:=_ : (v : Var) ‚Üí (e : AExpr) ‚Üí (l : Lab) ‚Üí Stmt
    skip : (l : Lab) ‚Üí Stmt
    _seq_ : (s‚ÇÅ : Stmt) ‚Üí (s‚ÇÇ : Stmt) ‚Üí Stmt
    if_then_else_ : (BExpr √ó Lab) ‚Üí (t : Stmt) ‚Üí (f : Stmt) ‚Üí Stmt
    while_do_ : (BExpr √ó Lab) ‚Üí (b : Stmt) ‚Üí Stmt
  -}
  
  {-
  postulate
    _‚âüS_ : Relation.Binary.Decidable {A = Stmt} _‚â°_
  -}

    
 

  {-
  Var*' : AExpr ‚Üí Pred Var Level.zero
  Var*' (var x‚ÇÅ) v‚ÇÅ = x‚ÇÅ ‚â° v‚ÇÅ
  Var*' (lit x‚ÇÅ) v‚ÇÅ = ‚ä•
  Var*' (a plus a‚ÇÅ) v‚ÇÅ = v‚ÇÅ ‚àà (Var*' a ‚à™ Var*' a‚ÇÅ)
  Var*' (a min a‚ÇÅ) v‚ÇÅ =  v‚ÇÅ ‚àà (Var*' a ‚à™ Var*' a‚ÇÅ)
  Var*' (a mul a‚ÇÅ) v‚ÇÅ = v‚ÇÅ ‚àà (Var*' a ‚à™ Var*' a‚ÇÅ)
                                              
                                              
  Var* : Stmt ‚Üí Pred Var Level.zero
  Var* ((i := x) l) v = i ‚â° v ‚ãÅ v ‚àà Var*' x
  Var* (skip x) v = ‚ä•
  Var* (s seq s‚ÇÅ) v = v ‚àà (Var* s ‚à™ Var* s‚ÇÅ)
  Var* (if c , l then t else f) v = v ‚àà (Var* t ‚à™ Var* f)
  Var* (while c , l do s) v = Var* s v

  Var*'-dec : (expr : AExpr) ‚Üí Decidable (Var*' expr)
  Var*'-dec (var x) v = x Data.String.‚âü v
  Var*'-dec (lit x) v = no (Œª x‚ÇÅ ‚Üí x‚ÇÅ)
  Var*'-dec (x plus x‚ÇÅ) v = Var*'-dec x v ‚ãÅ-dec Var*'-dec x‚ÇÅ v
  Var*'-dec (x min x‚ÇÅ) v = Var*'-dec x v ‚ãÅ-dec Var*'-dec x‚ÇÅ v
  Var*'-dec (x mul x‚ÇÅ) v = Var*'-dec x v ‚ãÅ-dec Var*'-dec x‚ÇÅ v
  
  Var*-dec : (program : Stmt) ‚Üí Decidable (Var* program)
  Var*-dec ((x := x‚ÇÅ) x‚ÇÇ) x‚ÇÉ = x Data.String.‚âü x‚ÇÉ ‚ãÅ-dec Var*'-dec x‚ÇÅ x‚ÇÉ
  Var*-dec (skip x) x‚ÇÅ = no (Œª z ‚Üí z)
  Var*-dec (program seq program‚ÇÅ) x = Var*-dec program x ‚ãÅ-dec Var*-dec program‚ÇÅ x
  Var*-dec (if x then program else program‚ÇÅ) x‚ÇÅ = Var*-dec program x‚ÇÅ ‚ãÅ-dec Var*-dec program‚ÇÅ x‚ÇÅ
  Var*-dec (while x do program) x‚ÇÅ =  Var*-dec program x‚ÇÅ
  -}

  {-
  data Block : Set where
    skip : (l : Lab) ‚Üí Block
    _:=_ : (x : Var) ‚Üí (a : AExpr) ‚Üí (l : Lab) ‚Üí Block
    bExpr : (c : BExpr) ‚Üí (l : Lab) ‚Üí Block
  -}

  {-
  countBlocks : Stmt ‚Üí ‚Ñï
  countBlocks ((v := e) l) = 1
  countBlocks (skip l) = 1
  countBlocks (x seq x‚ÇÅ) = countBlocks x Data.Nat.+ countBlocks x‚ÇÅ
  countBlocks (if x then x‚ÇÅ else x‚ÇÇ) = 1 Data.Nat.+ countBlocks x‚ÇÅ Data.Nat.+ countBlocks x‚ÇÇ
  countBlocks (while x do x‚ÇÅ) = 1 Data.Nat.+ countBlocks x‚ÇÅ

  module ùïç where
    open import Data.Vec public
  open import Data.Vec using (_‚à∑_ ; Vec)
  blocks : (p : Stmt) ‚Üí Vec Block (countBlocks p)
  blocks ((v := e) l) = ((v := e) l) ‚à∑ ùïç.[]
  blocks (skip l) = (skip l) ‚à∑ ùïç.[] 
  blocks (p seq p‚ÇÅ) = blocks p Data.Vec.++ blocks p‚ÇÅ
  blocks (if b , l then p else p‚ÇÅ) = (bExpr b l) ‚à∑ (blocks p Data.Vec.++ blocks p‚ÇÅ)
  blocks (while b , l do p) = (bExpr b l) ‚à∑ (blocks p)
  -}
  
  -- we want this function to be: Stmt ‚Üí Vec Block n
  -- but, we dont have proof that every label is present in the code.
  {-
  blocks : Stmt ‚Üí List Block
  blocks ((v := e) l) = [ (v := e) l ]
  blocks (skip l) = [ skip l ]
  blocks (s seq s‚ÇÅ) = blocks s ++ blocks s‚ÇÅ
  blocks (if proj‚ÇÅ , proj‚ÇÇ then s else s‚ÇÅ) = bExpr proj‚ÇÅ proj‚ÇÇ ‚à∑ blocks s ++ blocks s‚ÇÅ
  blocks (while proj‚ÇÅ , proj‚ÇÇ do s) = bExpr proj‚ÇÅ proj‚ÇÇ ‚à∑ blocks s
  -}
 
  -- but a quicker and dirtier solution is to use this function
  

--  open import Relation.Binary
{-
  open import Relation.Binary.Indexed
  exa : Stmt ‚Üí Setoid Var _ _
  exa s = record { Carrier = Var* s ; _‚âà_ = Œª {o} {a} x x‚ÇÅ ‚Üí a ‚â° o ; isEquivalence = record { refl = Œª {i} {x} ‚Üí refl ; sym = Œª { refl ‚Üí refl } ; trans = Œª{ refl refl ‚Üí refl } } }

  open import Function.Inverse
  open import Function.Equality renaming (setoid to setoid')
  open import Function.Equivalence renaming (setoid to setoid'')

  open import Relation.Binary.On renaming (setoid to setoid''')



  postulate
    
    inv : Œ£[ n ‚àà ‚Ñï ] ((s : Stmt) ‚Üí Inverse ((exa s) at "x") (setoid (Fin n)))
  -}

        {-record { to = record { _‚ü®$‚ü©_ = to ; cong = Œª{ refl ‚Üí refl } } ; from = record { _‚ü®$‚ü©_ = from ; cong = Œª{ refl ‚Üí refl } } ; inverse-of =
        record { left-inverse-of = pa ; right-inverse-of = pb } }
        -}



  


  {-
  maxN : Stmt ‚Üí ‚Ñï
  maxN (v := e) = 1
  maxN skip = 1
  maxN (s seq s‚ÇÅ) = maxN s + maxN s‚ÇÅ
  maxN (if x then s else s‚ÇÅ) = 1 + maxN s + maxN s‚ÇÅ
  maxN (while x do s) = 1 + maxN s

  maxN' : Stmt ‚Üí Œ£[ n ‚àà ‚Ñï ] Fin n
  maxN' (v := e) = 1 , Fin.zero
  maxN' skip = 1 , Fin.zero
  maxN' (s seq s‚ÇÅ) = (proj‚ÇÅ (maxN' s) + proj‚ÇÅ (maxN' s‚ÇÅ)) , {!(Data.Fin.pred (proj‚ÇÇ (maxN' s))) fin+ (proj‚ÇÇ (maxN' s‚ÇÅ))!}
  maxN' (if x then s else s‚ÇÅ) = {!!} , {!!}
  maxN' (while x do s) = {!!} , {!!}

  {-
  voor alle statements geldt niet dat er een label bestaat voor assignment,skip,if en while, die in die statement zit en groter is
  dan het maximum dat berekent is voor deze statement.

  -}
                             
  open import Data.Nat.Properties
  conv : (s : Stmt) ‚Üí LblStmt (maxN s)
  conv s = proj‚ÇÇ (conv' s ({!!}))
    where conv' : (s' : Stmt) ‚Üí (Fin (maxN s)) ‚Üí (Fin (maxN s)) √ó LblStmt (maxN s)
          conv' (v := e) n = Data.Fin.pred n , ((v := e) n)
          conv' skip n = Data.Fin.pred n , skip n 
          conv' (s' seq s'') n =
            let (n‚ÇÇ , s‚ÇÇ) = conv' s'' n
                (n‚ÇÅ , s‚ÇÅ) = conv' s' n‚ÇÇ
            in n‚ÇÅ , s‚ÇÅ seq s‚ÇÇ
          conv' (if x then s' else s'') n =
            let (n‚ÇÅ , s‚ÇÅ) = conv' s'' n
                (n‚ÇÇ , s‚ÇÇ) = conv' s' n‚ÇÅ
            in Data.Fin.pred n‚ÇÇ , (if x , n‚ÇÇ then s‚ÇÇ else s‚ÇÅ)
          conv' (while x do s') n =
            let (n‚ÇÅ , s‚ÇÅ) = conv' s' n
            in (Data.Fin.pred n‚ÇÅ) , (while x , n‚ÇÅ do s‚ÇÅ)
  -}


  {-
  module x (n : ‚Ñï) where
    open import Data.List.NonEmpty
    Lab : Set
    Lab = Fin n

    mutual
      data Stmt' : Set where
        _:=_ :  Stmt'
        skip :  Stmt'
        if_then_else_ :  Stmt'
        while_do_ : Stmt'

      record LblStmt : Set where
        field
          lab  : Lab
          stmt : Stmt'
          
      Program : Set
      Program = List‚Å∫ LblStmt
  -}
  {-  Decidable _‚äé_
  data Type : Set where
   TBool : Type
   TUnit : Type
   TInt : Type

  
  data Term : Type -> Set where
    var : ‚àÄ{a} -> String -> Term a
    _:=_ : ‚àÄ{a} -> String -> Term a -> Term TUnit
    if_then_else_ : ‚àÄ{a} -> Term TBool -> Term a -> Term a -> Term a
    while_do_ : ‚àÄ{a} -> Term TBool -> Term a -> Term a
    skip : Term TUnit
    _seq_ : ‚àÄ{a b} -> Term a -> Term b -> Term TUnit
    true : Term TBool
    false : Term TBool
    _and_ : Term TBool -> Term TBool -> Term TBool
    _or_ : Term TBool -> Term TBool -> Term TBool
    not_ : Term TBool -> Term TBool
    CInt : ‚Ñï -> Term TInt
    _plus_ : Term TInt -> Term TInt -> Term TInt
 
  
  infixr 2 _seq_
  infixr 3 _:=_

  exampleProgram : Term TUnit
  exampleProgram = "v" := CInt 1 seq "u" := CInt 1 seq if false then skip else while true or true do (_:=_ {TInt} "t" (var "u") seq _:=_ {TInt} "u" (var "v") seq "v" := var "u" plus var "t")



  data UntypedTerm : Set where
    var : String -> UntypedTerm 
    _:=_ : String -> UntypedTerm -> UntypedTerm
    if_then_else_ : UntypedTerm -> UntypedTerm -> UntypedTerm -> UntypedTerm
    while_do_ : UntypedTerm -> UntypedTerm -> UntypedTerm
    skip : UntypedTerm 
    _seq_ : UntypedTerm -> UntypedTerm -> UntypedTerm 
    true : UntypedTerm 
    false : UntypedTerm
    _and_ : UntypedTerm -> UntypedTerm -> UntypedTerm 
    _or_ : UntypedTerm -> UntypedTerm -> UntypedTerm 
    not_ : UntypedTerm -> UntypedTerm
    CInt : ‚Ñï -> UntypedTerm 
    _plus_ : UntypedTerm -> UntypedTerm -> UntypedTerm

  toUntypedTerm : ‚àÄ {a} -> Term a -> UntypedTerm
  toUntypedTerm (var x) = var x
  toUntypedTerm (x := x‚ÇÅ) = x := toUntypedTerm x‚ÇÅ
  toUntypedTerm (if x then x‚ÇÅ else x‚ÇÇ) = if toUntypedTerm x then toUntypedTerm x‚ÇÅ else toUntypedTerm x‚ÇÇ
  toUntypedTerm (while x do x‚ÇÅ) = while toUntypedTerm x do toUntypedTerm x‚ÇÅ
  toUntypedTerm skip = skip
  toUntypedTerm (x seq x‚ÇÅ) = toUntypedTerm x seq toUntypedTerm x‚ÇÅ
  toUntypedTerm true = true
  toUntypedTerm false = false
  toUntypedTerm (x and x‚ÇÅ) = toUntypedTerm x and toUntypedTerm x‚ÇÅ
  toUntypedTerm (x or x‚ÇÅ) = toUntypedTerm x or toUntypedTerm x‚ÇÅ
  toUntypedTerm (not_ x) = not toUntypedTerm x
  toUntypedTerm (CInt x) = CInt x
  toUntypedTerm (x plus x‚ÇÅ) = toUntypedTerm x plus toUntypedTerm x‚ÇÅ

  record LabeledTerm : Set where
    constructor labeledTerm
    field
      label : ‚Ñï
      term : UntypedTerm

  open import Data.Product
  mklabel : UntypedTerm ‚Üí LabeledTerm
  mklabel = proj‚ÇÇ ‚àò label' 0
    where label' : (current : ‚Ñï) ‚Üí UntypedTerm ‚Üí (‚Ñï √ó LabeledTerm)
          label' n t@(var x) = (suc n) , (labeledTerm n t)
          label' n (x := t) = let (n' , lt) = label' n t
                              in suc n' , labeledTerm n' {!x := (lt!}
          label' n (if t then t‚ÇÅ else t‚ÇÇ) = {!!}
          label' n (while t do t‚ÇÅ) = {!!}
          label' n skip = {!!}
          label' n (t seq t‚ÇÅ) = {!!}
          label' n true = {!!}
          label' n false = {!!}
          label' n (t and t‚ÇÅ) = {!!}
          label' n (t or t‚ÇÅ) = {!!}
          label' n (not t) = {!!}
          label' n (CInt x) = {!!}
          label' n (t plus t‚ÇÅ) = {!!}

  Stmt : Set
  Stmt = UntypedTerm

  Label : Set
  Label = ‚Ñï
  
  init : Stmt ‚Üí Label
  init = {!!}
  
  -}
