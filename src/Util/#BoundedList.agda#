open import Data.List
open import Data.Nat renaming (_â‰Ÿ_ to _â‰Ÿâ„•_)
open import Data.Nat.Properties
open import Data.Product
open import Function.Inverse
open import Data.Fin
open import Algebra
open import Relation.Binary.PropositionalEquality
open CommutativeSemiring commutativeSemiring
open import Algebra.Operations semiring
open import Function.Equality using (_âŸ¨$âŸ©_)  
open import Relation.Nullary.Decidable
open import Relation.Nullary
open import Relation.Binary


module Util.BoundedList where

  data BoundedList' {a} (A : Set a) (k : â„•) : â„• â†’ Set a where
    nil : BoundedList' A k â„•.zero
    cons' : {i : â„•} â†’ A â†’ BoundedList' A k i â†’ .(suc i Data.Nat.â‰¤ k) â†’ BoundedList' A k (suc i)

  BoundedList : âˆ€{a} â†’ (A : Set a) â†’ (k : â„•) â†’ Set a
  BoundedList A k = Î£[ n âˆˆ â„• ] BoundedList' A k n

  dropLast' : âˆ€{a} â†’ {A : Set a} â†’ {k n : â„•} â†’ BoundedList' A k (suc n) â†’ BoundedList' A k n
  dropLast' {n = â„•.zero} (cons' x xâ‚ xâ‚‚) = nil
  dropLast' {n = suc n} (cons' x xâ‚ xâ‚‚) = cons' x (dropLast' xâ‚) (â‰¤â‡’predâ‰¤ (suc (suc n)) _ xâ‚‚)

  dropLast :  âˆ€{a} â†’ {A : Set a} â†’ {k : â„•} â†’ BoundedList A k â†’ BoundedList A k
  dropLast (zero , projâ‚‚) = â„•.zero , projâ‚‚
  dropLast (suc n , projâ‚‚) = n , dropLast' projâ‚‚

  cons :  âˆ€{a} â†’ {A : Set a} â†’ {k : â„•} â†’ A â†’ BoundedList A k â†’ BoundedList A k
  cons {k = k} a (n , xs) with suc n Data.Nat.â‰¤? k
  cons {k = k} a (n , xs) | yes p = (suc n) , (cons' a xs p)
  cons {k = k} a (zero , nil) | no Â¬p = (â„•.zero , nil)
  cons {k = k} a (suc n , cons' x xs xâ‚) | no Â¬p = (suc n , cons' a (dropLast' (cons'Â x xs xâ‚)) xâ‚)

  open import Relation.Binary.List.Pointwise renaming (decidable-â‰¡ to decidable-â‰¡-pointwise)


  decidable-â‰¡' : âˆ€{a k n} {A : Set a} â†’ Decidable {A = A} _â‰¡_ â†’ Decidable {A = BoundedList' A k n} _â‰¡_
  decidable-â‰¡' _â‰Ÿ_ nil nil = yes _â‰¡_.refl
  decidable-â‰¡' _â‰Ÿ_ (cons' x xs xp) (cons' y ys yp) with x â‰Ÿ y
  decidable-â‰¡' _â‰Ÿ_ (cons' x xs xp) (cons' .x ys yp) | yes _â‰¡_.refl with decidable-â‰¡' _â‰Ÿ_ xs ys
  decidable-â‰¡' _â‰Ÿ_ (cons' x xs xp) (cons' .x .xs yp) | yes _â‰¡_.refl | yes _â‰¡_.refl = yes _â‰¡_.refl
  decidable-â‰¡' _â‰Ÿ_ (cons' x xs xp) (cons' .x ys yp) | yes _â‰¡_.refl | no Â¬p = no (Î»{ _â‰¡_.refl â†’ Â¬p _â‰¡_.refl})
  decidable-â‰¡' _â‰Ÿ_ (cons' x xs xp) (cons' y ys yp) | no Â¬p = no (Î»{ _â‰¡_.refl â†’ Â¬p _â‰¡_.refl})


  decidable-â‰¡ : âˆ€{a k} {A : Set a} â†’ Decidable {A = A} _â‰¡_ â†’ Decidable {A = BoundedList A k} _â‰¡_
  decidable-â‰¡ _â‰Ÿ_ (i , xs) (j , ys) with i â‰Ÿâ„• j
  decidable-â‰¡ _â‰Ÿ_ (i , xs) (.i , ys) | yes _â‰¡_.refl with decidable-â‰¡' _â‰Ÿ_ xs ys
  decidable-â‰¡ _â‰Ÿ_ (i , xs) (.i , .xs) | yes _â‰¡_.refl | yes _â‰¡_.refl = yes _â‰¡_.refl
  decidable-â‰¡ _â‰Ÿ_ (i , xs) (.i , ys) | yes _â‰¡_.refl | no Â¬p = no (Î»{ _â‰¡_.refl â†’ Â¬p _â‰¡_.refl})
  decidable-â‰¡ _â‰Ÿ_ (i , xs) (j , ys) | no Â¬p = no (Î»{ _â‰¡_.refl â†’ Â¬p _â‰¡_.refl})

  syntax decidable-â‰¡ _â‰Ÿ_ a b = a â‰ŸâŸ¨ _â‰Ÿ_ âŸ© b


  open import Data.String
  showBLâ€² : âˆ€{a k n} {A : Set a} â†’ (showA : A â†’ String) â†’ BoundedList' A k n â†’ String
  showBLâ€² showA nil = ""
  showBLâ€² showA (cons' x xâ‚ xâ‚‚) = showA x Data.String.++ ", " Data.String.++ showBLâ€² showA xâ‚

  showBL : âˆ€{a k} {A : Set a} â†’ (showA : A â†’ String) â†’ BoundedList A k â†’ String
  showBL f (n , bl) = showBLâ€² f bl
  
--  Data.String.fromList (ğ•ƒ.concat (intersperse (Data.String.toList "\n ") (ğ•.toList (ğ•.map (Î» Î´ â†’ {!Inverse.from BoundedListâ†” âŸ¨$âŸ© Î´!}) (allFin r))))) --Data.List.map ? (ğ•.toList (allFin n))
  {-
Î£-syntax : âˆ€ {a b} (A : Set a) â†’ (A â†’ Set b) â†’ Set (a âŠ” b)
Î£-syntax = Î£

syntax Î£-syntax A (Î» x â†’ B) = Î£[ x âˆˆ A ] B
-}



{-
    
-}
  open import Data.Vec
  allBoundedLists' : âˆ€{a k n} â†’ {A : Set a} â†’ Î£[ n âˆˆ â„• ] A â†” Fin n â†’ List (BoundedList' A k n)
  allBoundedLists' {a} {k} {â„•.zero} (m , Aâ†”) = Data.List.[ nil ]
  allBoundedLists' {a} {k} {suc n} (m , Aâ†”) with suc n Data.Nat.â‰¤? k
  allBoundedLists' {a} {k} {suc n} (m , Aâ†”) | yes p = Data.List.concat (Data.List.map (Î» x â†’ Data.List.map (Î» xs â†’ cons' (Inverse.from Aâ†” âŸ¨$âŸ© x) xs p) (allBoundedLists' {a} {k} {n} (m , Aâ†”))) (Data.Vec.toList (allFin m)))
  allBoundedLists' {a} {k} {suc n} (m , Aâ†”) | no Â¬p = []

  

  allBoundedLists : âˆ€{a k} â†’ {A : Set a} â†’ Î£[ n âˆˆ â„• ] A â†” Fin n â†’ List (BoundedList A k)
  allBoundedLists {a} {k} (m , Aâ†”) = Data.List.concat (Data.List.map (Î» x â†’ Data.List.map (Î» xs â†’ (toâ„• x , xs)) (allBoundedLists' {a} {k} {toâ„• x} (m , Aâ†”))) (Data.Vec.toList (allFin (suc k))))
  --(Data.Vec.map (Î» x â†’ (toâ„• x) , {!Data.List.allBoundedLists' {a} {k} {toâ„• x} (m , Aâ†”)!}) (allFin k)
  {-
  allBoundedLists {a} {â„•.zero} (n , Aâ†”) = []
  allBoundedLists {a} {suc k} (n , Aâ†”) = Data.List.map (Î» x â†’ (suc k , x)) (allBoundedLists' {a} {suc k} {suc k} (n , Aâ†”)) Data.List.++ {!!} --allBoundedLists {a} {k} (n , Aâ†”)
-}
  example : List (BoundedList (Fin 2) 2)
  example = allBoundedLists (2 , Function.Inverse.id)

  {-
  isBijectiveToFin : âˆ€{a k} â†’ {A : Set a} â†’ Î£[ n âˆˆ â„• ] A â†” Fin n â†’ Î£[ r âˆˆ â„• ] BoundedList A k â†” Fin r
  isBijectiveToFin {a} {k} {A} (m , Aâ†”) = (length (allBoundedLists {k = k} (m , Aâ†”))) , record { to = â†’-to-âŸ¶ (Î» x â†’ {!index!}) ; from = {!!} ; inverse-of = {!!} }
  -}

  postulate
    isBijectiveToFin : âˆ€{a k} â†’ {A : Set a} â†’ Î£[ n âˆˆ â„• ] A â†” Fin n â†’ Î£[ r âˆˆ â„• ] BoundedList A k â†” Fin r
  
    
{-
  module _  {a} {A : Set a} (n : â„•) (inv : A â†” Fin n) where
    bList'ToFin : âˆ€{k} â†’ BoundedList' A k n â†’ Fin (suc n)
    bList'ToFin nil = Fin.zero
    bList'ToFin (cons' x xâ‚ xâ‚‚) = suc {!bList'ToFin!}
  
    listToFin : âˆ€{k} â†’ BoundedList A k â†’ Fin (n ^ k)
    listToFin {â„•.zero} (.0 , nil) = Fin.zero
    listToFin {â„•.zero} (.(suc _) , cons' x projâ‚‚ ())
    listToFin {suc k} (.0 , nil) = {!Fin.zero!}
    listToFin {suc k} (.(suc _) , cons' x projâ‚‚ xâ‚) = {!!}
    {-(â„•.zero , nil) = {!Fin.zero!}
    listToFin (suc n , cons' x projâ‚‚ xâ‚) = {!!} -- {!Inverse.to inv âŸ¨$âŸ© x * ?!} -}

  isBijectiveToFin : âˆ€{a k} â†’ {A : Set a} â†’ Î£[ n âˆˆ â„• ] A â†” Fin n â†’ Î£[ r âˆˆ â„• ] BoundedList A k â†” Fin r
  isBijectiveToFin {k = k} (n , inv) = n ^ k , record { to = â†’-to-âŸ¶ (listToFin n inv) ; from = {!!} ; inverse-of = {!!} }
  -}

{-
  prefix : âˆ€{a} â†’ {A : Set a} â†’ {k n : â„•} â†’ BoundedList A k (suc n) â†’ BoundedList A k n
  prefix {aâ‚} {A} {k} {zero} (cons' x xâ‚ xâ‚‚) = nil
  prefix {aâ‚} {A} {.(suc _)} {suc n} (cons' x xâ‚ (sâ‰¤s xâ‚‚)) = cons' x (prefix xâ‚) {! !}

  cons : âˆ€{a} â†’ {A : Set a} â†’ {k : â„•} â†’ A â†’ FList A k â†’ FList A k
  cons {k = k} x (projâ‚ , projâ‚‚) with suc projâ‚ Data.Nat.â‰¤? k
  cons {_} {_} {k} x (projâ‚ , projâ‚‚) | yes o = suc projâ‚ , cons' x projâ‚‚ o 
  cons {_} {_} {k} x (zero , projâ‚‚) | no Â¬p = zero , nil
  cons {_} {_} {k} x (suc projâ‚ , projâ‚‚) | no Â¬p = suc projâ‚ , cons' x (prefix projâ‚‚) {!!} -- projâ‚ , {!prefix !} --cons' x {!!} {!!}


  record BoundedList {a} (A : Set a) (k : â„•) : Set a where
    constructor boundedList
    field
      list : List A
      .isBounded : length list â‰¤ k

  dropLast : âˆ€{a} â†’ {A : Set a} â†’ {k : â„•} â†’ BoundedList A k â†’ BoundedList A k 
  dropLast (boundedList [] isBounded) = boundedList [] zâ‰¤n
  dropLast (boundedList (x âˆ· []) isBounded) = boundedList [] zâ‰¤n
  dropLast (boundedList (x âˆ· xâ‚ âˆ· list) isBounded) = {!!}


  toList : âˆ€{a k} â†’ {A : Set a} â†’ BoundedList A k â†’ List A
  toList (boundedList list isBounded) = list
-}  

